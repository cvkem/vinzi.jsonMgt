<?xml version="1.0" encoding="UTF-8"?>
<cdp>
 <clojure namespace="vinzi.cdp.ns.cdm">
 	;; include some libraries
  (use 'clojure.tools.logging)
;;(use       'vinzi.cdm.globals)
  (require '(clojure [string :as str])
  	       '(clojure.java [jdbc :as sql]))
  (require  '(vinzi.pentaho [connect :as conn])
  			'(vinzi.jsonMgt
;;	     	  [hibernate :as hibps]
	     	  [core :as jmgt]
	     	  [globals :as glb]
	     	  [init-persistentstore :as ips]))
	     
  (def initialized? (atom false))

  (def helpModus (atom false))

  (def cdfdePostfix ".cdfde")

  (def databaseCfg {:database_interface "hibernate"
  ;; further options for the dabase can be intered below as key-value pairs.
  })
  
  (defn initialize
    "Initialize the system, read config-file and install interfaces."
    []
    (when (not @initialized?)
      (swap! initialized? (fn [_] true))
      (info jmgt/introMessage)
      (glb/setDefPostfix cdfdePostfix)

	  ;; select the persistent-storage backend (and initialize the databases when needed)
       (ips/init-persistentstore databaseCfg)))


(defn get-command-rec 
 "Generate a command for jsonMgt based on action and the :src and :dst from the params.
  Further parameter-checking will be added."
  [params]
  (let [get-param (fn [theKey] 
  					(let [par (get params theKey) 
        				  par (when par (str/split (str/trim par) #"\s+"))
        				  par (if (and (= (count par) 1) (= (first par) "")) '() par)]
    					par))
  		action (str/lower-case (str/trim (:action params)))
        src    (get-param "source")
        dst    (get-param "destinations")
        msg    (get-param params)]
    {:command action
     :src  src
     :dst  dst
     :msg  msg}))


  (defn process-jsonMgt-command
    "Collect the relavant data and call the jsonMgt."
    [params]
    (initialize)
    (let [lpf "(process-jsonMgt-command): "
    	  commandRec (get-command-rec params)
          action     (:action commandRec)]
      (letfn [(switch-to-help-modus []
                                    (println "switch help modus true")
                                    (swap! helpModus (fn [_] true))
                                    (str "Click a command button to view help.\n"
                                         "Click help again for an overview of the available commands)"))
              (procComm []
                        (info "process command " action)
                        (if (= action "help")
                          (switch-to-help-modus)
                            (let [response (with-out-str
                                             (jmgt/processCommand commandRec))
                                  response (if (or (nil? response)
                                                   (= response ""))
                                             (str "Succesfull performed command "
                                                  commandRec)
                                             response)]
                              response)))
              (procHelp []
                        (swap! helpModus (fn [_] false))
                        (with-out-str (jmgt/processCommand {:command "help"
                                                            :src  (list action)
                                                            :dst  '()})))]
             (let [response (if @helpModus (procHelp) (procComm))]
               (info "Received result: " response)
               response))))
  
 </clojure>


  <action
     accessId="initialize"
     description="Initialize the system."
     >
	<clojure>
	(initialize)
	</clojure>
   <params>
   </params>
 </action>



  <action
     accessId="jqGetDocRoot"
     description="Get the docRoot (base of the pentaho solution folder in the file-system)."
     >
	<clojure>
	(fn []
	  (initialize)   ;; force initialization (if not performed already)
      (conn/get-solution-folder)
    )
	
	</clojure>
   <params>
   </params>
 </action>



  <action
     accessId="genFileView"
     description="Generate data to show the files in a viewer."
     >
	<clojure>
	(fn [params]
	   (info "genFileView still needs to be implemented")
	  "to be implemented"
    )
	</clojure>
   <params>
   </params>
 </action>


  <action
     accessId="process-jsonMgt-command"
     description="Process a jsonMgt-command."
     >
	<clojure>
	(process-jsonMgt-command params)
	</clojure>
   <params>
      <param id="action"/>
      <param id="source"  default=""/>
      <param id="destinations" default=""/>
      <param id="msg" default=""/>
   </params>
 </action>




  <action
     accessId="showTable"
     description="generate data to show a table."
     >
	<clojure>
	(fn [params]
	   (info "genFileView still needs to be implemented")
	  "to be implemented"
    )
	</clojure>
   <params>
   </params>
 </action>






</cdp>
