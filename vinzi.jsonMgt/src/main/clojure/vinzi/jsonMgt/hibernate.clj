(ns vinzi.jsonMgt.hibernate
  (:use vinzi.hib-connect.bridge)
  (:use [vinzi
	 jsonZip
	 jsonDiff   ;; needed for the definition of vinzi.jsonDiff.Patch
	 ]
	[vinzi.jsonMgt globals]
	[clojure.pprint])
  (:require  [vinzi.jsonMgt [persistentstore :as ps]]
	     [clojure.data
	      [json :as json]])
  (:use [vinzi.jsonMgt.hib.clj errorEntry actionEntry Commit TrackInfo DbPatch])
  (:require [vinzi.hib-connect [bridge :as hib]])
  (:import [vinzi.jsonDiff Patch]
	   [java.io File]
	   [java.util Date]
	   [java.sql SQLException Timestamp]
	   )
 )


(defn db_call-with-connection [f & args]
  ;; dummy procedure as 'hib-connect' does not work with a dynamic var (yet).
  ;; needed as the persistantstore interface requires this.
  (let [res (apply f args)]
    res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Auxiliary (helper) functions
;;


(defn dbRecToPatch
  "translate a database-record 'rec' to a Patch object
   (same as in database.clj; no changes needed)."
  [rec]
  (let [{:keys [path action patchkey value]} rec
	pathList (getPathList path)
	act      (keyword action)
	pKey     (keywordize patchkey)
	val      (json/read-json value) ]
    (Patch. pathList act pKey val)))


(defn patchToDbRec
  "Translate a patch object to a database record (hash-map).
  Hibernate specific function."
  [trackId patch dt]
  (create-DbPatch trackId dt
		  (getPathStrPatch patch)
		  (name (:action patch))
		  (str (:key patch))
		  (json/json-str (:value patch))))


(defn store-in-hib
  "Store 'it' in a hib. This function is only used to switch on reporing"
  [it]
  (hib/store-hib it))


(defn db_writeErrorEntry
  [errorEntry]
  ;;  (sql/insert-records (getErrorLogDb) errorEntry)
  (store-in-hib errorEntry)
  true)

(defn db_writeActionEntry
  [actionEntry]
;;  (sql/insert-records (getActionLogDb) actionEntry)
  (store-in-hib actionEntry)
  true)




(defn db_initScheme
  "Initialize a scheme (or database) by creating the all five tables. The function only returns true if all five operations are succesfull. An action-log entry is generated for each table, so the action-table is created first."
  []
  (let [dt (getCurrDateTime)]
    (writeActionEntry "No initScheme needed: Tables will be generated by Hibernate." dt)))

;;
;;  Functions to write data to the databases
;;

(defn db_createTrack
  "add an information record for this track, and returns the full trackInfo record for this track (used to generate other tables)."
  [trackName fileLocation]
  (let [;;trackInfoDb (getTrackInfoDb)
	getTrackRec (format "FROM TrackInfo WHERE track_name = '%s'" trackName)]
    ;; create a track-info record
    (hib/with-query-results recs [getTrackRec]
      (if (>  (count recs) 0)
	(do
	  (addMessage trackName "Track already exists in database.")
	  nil)  ;; return nil (signaling no track generated
	(let [trackinf (create-TrackInfo fileLocation trackName)]
	  ;; (sql/insert-records
	  ;;  trackInfoDb
	  ;;  {:file_location fileLocation   :track_name trackName})
	  (store-in-hib trackinf)
	  ;; read it (now with an the 'id' set
	  (hib/with-query-results recs [getTrackRec]
	    (let [ti (first recs)
		  id (:id ti)
		  ti (assoc ti :track_id id)]
	      ;; expose the id as track_id
	      (pln "hib/db_create_rec returns: " ti)
	      ti)))))))



  

(defn db_writeCommit
  "Add a full-copy of the track to 'trackId' with 'jsonContents'
  and date/time from dt (does not add patches and 'jsonContents' should be a json-string, not a hash-map object)."
  [trackId jsonContents dt]
  {:pre [(isJson? jsonContents)
	 (not= (type trackId) java.lang.String)]}
  (pln "in addTrackCopy jsonContents of type: " (type jsonContents))
  (pln "Adding a version with contents: " jsonContents)
  (let [comm (create-Commit trackId dt jsonContents)]
	  (store-in-hib comm)))
  ;; (sql/insert-records (getCommitDb)
  ;; 		      {:track_id trackId
  ;; 		       :datetime dt
  ;; 		       :contents jsonContents}))


(defn db_writePatches
  "Add the 'patches' of the track to 'trackname' with date/time from 'dt'."
  [trackId patches dt]
  {:pre [(not= (type trackId) java.lang.String)]}
    (doseq [p patches]
      ;; Possibly sql/insert-values with a vector containing all patches is faster
      (let [rec (patchToDbRec trackId p dt)]
;;	(sql/insert-records (getPatchDb) rec)
	  (store-in-hib rec)
	)))
 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Functions to retrieve (get) data from the databases
;;

(defn getAllItems [table]
  (let [query (format "FROM %s" table)]
    (hib/with-query-results res  [query]
      (doall res))))

(defn db_getAllActions[]
  (getAllItems "actionEntry"))

(defn db_getAllTracks[]
  (let [at (getAllItems "TrackInfo")
	;; expose a copy of id as track_id
	at (map #(assoc % :track_id (:id %)) at)]
    at))

(defn db_getAllErrors[]
  (getAllItems "errorEntry"))



(defn db_getTrackInfo
  " get the path in the file-system that corresponds to trackName
    (should be only one track)"
  [trackName]
  (let [query (format "FROM TrackInfo WHERE track_name = '%s'" trackName)]
    (pln " getTracks: generated query " query)
      (hib/with-query-results res  [query]
	(pln "results of query")
	(pln res)
	(if (not= (count res) 1)
	  (addMessage trackName "ERROR: There are %s versions of this track (action cancelled)."
		      (count res))
	    (let [ti (first res)
		  id (:id ti)
		  ti (assoc ti :track_id id)]
	      ;; expose the id as track_id
	      (pln "hib/db_create_rec returns: " ti)
	      ti)))))



(defn db_getCommit
  "Get the data of the commit of at 'depth' steps from the last commit from the database. The function returns exactly one record (not a sequence)."
  [trackId depth]
  {:pre [(not= (type trackId) java.lang.String)]}
  (letfn [(getCommitId []
	     (let[cids   (hib/query-hib (str  "SELECT cmt.id, cmt.datetime"
					      " FROM Commit cmt "
					      " WHERE track_id = " trackId))
		  cids (sort #(compare (second %1) (second %2)) cids)
		  cids (reverse cids)
		  cids (drop depth cids)
		  id   (ffirst cids)]
	       id))]
	  (if-let [cid (getCommitId)]
	    (let [query (str "FROM Commit cmt WHERE cmt.id = " cid)]
	      (hib/with-query-results selectId
		[query]
		;; and extract the corresponding version
		(when-let [id (:id (first selectId))]
		  (hib/with-query-results res
		    [(format "FROM Commit WHERE id=%s" id)]
		    (assert (= 1 (count res)))
		    (first res)))))
	    (let [err (str "No commit at depth " depth
			   "for track with id " trackId)
		  trackName (str "Trackid=" trackId)]
	      (addErrEntry err (getCurrDateTime) trackName)))))



(defn db_getPatches
  "Retrieve the patches since 'depth' commits before the current commit. The returned list will be in the db-format. To get patches in the original format use 'retrievePatches'."
  [trackId dt]
  {:pre [(not= (type trackId) java.lang.String)]}
    (let [query (format "FROM DbPatch WHERE datetime >= '%s' ORDER BY datetime" dt)]
      (let [res (hib/query-hib  query)]
	(pln "\nin hibernate getPatches")
	(pln " The results are: ")
	(doall (map pln res))
	(let [tres (doall (map  dbRecToPatch res))]
	  (pln "AND after the transform")
	  (doall (map pln tres))
	  tres))))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Functions to drop data from the databases
;;

(defn db_dropLastCommit
  "Drop the last commit from the database. Will remove the patches that belong to this commit too. The files in the file-system will not be touched."
  [commitId dt]
  (let [dp (delete-hib (format "FROM Commit WHERE datetime >= '%s'" dt))
	dc (delete-hib (format "FROM Commit WHERE id = %s" commitId))]
    dp))


(defn db_dropTrackInfo
  "Drop the track-info record for track_id = 'trackId'. Assume that all commits have been dropped already. No checks performed!"
  [trackId]
  (delete-hib (format "FROM TrackInfo WHERE id = %s" trackId)))


(defn db_initDatabase [cfg]
  (hib/force-open-hib))


(defn db_closeDatabase []
  (hib/close-hib))


(defn installDatabaseAsPS []
  (ps/rebindPersistentStore
   db_initDatabase db_call-with-connection
   db_writeErrorEntry db_writeActionEntry
   db_createTrack db_writeCommit db_writePatches
   db_getAllTracks db_getAllActions db_getAllErrors
   db_getTrackInfo db_getCommit db_getPatches
   db_dropLastCommit db_dropTrackInfo
   db_closeDatabase))


